<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Yavalath</title>
<style>
  body{margin:0;font-family:sans-serif;background:#f4f5f7;display:flex;flex-direction:column;align-items:center}
  .board-wrap{width:min(900px,96vw);aspect-ratio:1/1;background:#1a1c1f;border-radius:22px;margin:8px;position:relative}
  svg{width:100%;height:100%}
  .hex{fill:#242a31;stroke:#7f8ea3;stroke-width:2}
  .hex.empty:hover{filter:brightness(1.2);cursor:pointer}
  .stone circle{stroke:#0006;stroke-width:1.5}
  .stone.white circle{fill:url(#marbleWhite)}
  .stone.yellow circle{fill:url(#marbleYellow)}
  .last-anim circle{animation:pop .2s ease-out forwards}
  @keyframes pop{0%{transform:scale(0);opacity:.2}100%{transform:scale(1);opacity:1}}
  .win-line{stroke:red;stroke-width:10;stroke-linecap:round;filter:drop-shadow(0 0 6px red);opacity:.85;animation:pulse 1s ease-in-out infinite}
  @keyframes pulse{0%{opacity:.5}50%{opacity:1}100%{opacity:.5}}
  #banner{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
  #bannerMsg{background:rgba(0,0,0,.6);color:#fff;padding:10px 14px;border-radius:12px;font-size:1.4rem}
</style>
</head>
<body>
<header>
  <span id="turnText">白の番です</span>
  <select id="aiLevel">
    <option value="off">AI:OFF</option>
    <option value="easy">弱</option>
    <option value="medium">中</option>
    <option value="hard">強</option>
    <option value="oni">鬼</option>
  </select>
  <button id="undoBtn">1手戻す</button>
  <button id="resetBtn">リセット</button>
</header>
<div id="score">白:0 勝 - 黄:0 勝</div>
<div class="board-wrap">
  <svg id="board" viewBox="0 0 1000 1000"></svg>
  <div id="banner"><div id="bannerMsg"></div></div>
</div>

<script>
// 基本設定
const RADIUS=5, HEX_SIZE=42, DIRS=[[1,0],[0,1],[1,-1]];
let boardState=new Map(),current='white',history=[],gameOver=false,endMessage='',score={white:0,yellow:0},aiLevel='off';
const svg=document.getElementById('board');
const key=(q,r)=>`${q},${r}`;

// 座標変換
function axialToPixel(q,r,size){return[size*Math.sqrt(3)*(q+r/2),size*1.5*r];}
function hexPath(cx,cy,size){let pts=[];for(let i=0;i<6;i++){let a=Math.PI/180*(60*i-30);pts.push([cx+size*Math.cos(a),cy+size*Math.sin(a)]);}return "M"+pts.map(p=>p.join(",")).join("L")+"Z";}
function computeLayout(){let xs=[],ys=[];for(let r=-RADIUS+1;r<=RADIUS-1;r++)for(let q=-RADIUS+1;q<=RADIUS-1;q++)if(Math.abs(q+r)<=RADIUS-1){let[x,y]=axialToPixel(q,r,HEX_SIZE);xs.push(x);ys.push(y);}let minX=Math.min(...xs),maxX=Math.max(...xs),minY=Math.min(...ys),maxY=Math.max(...ys),pad=70;let scX=(1000-pad*2)/(maxX-minX),scY=(1000-pad*2)/(maxY-minY);let scale=Math.min(scX,scY);let offX=(1000-(maxX-minX)*scale)/2-minX*scale,offY=(1000-(maxY-minY)*scale)/2-minY*scale;return{scale,offX,offY};}
const L=computeLayout();

let lastWinSegment=null;
function render(){svg.innerHTML='';
 let defs=document.createElementNS('http://www.w3.org/2000/svg','defs');
 defs.innerHTML=`<radialGradient id="marbleWhite" r="100%"><stop offset="0%" stop-color="#fff"/><stop offset="100%" stop-color="#ddd"/></radialGradient>
 <radialGradient id="marbleYellow" r="100%"><stop offset="0%" stop-color="#ffe079"/><stop offset="100%" stop-color="#caa200"/></radialGradient>`;
 svg.appendChild(defs);
 let centers={};
 for(let r=-RADIUS+1;r<=RADIUS-1;r++)for(let q=-RADIUS+1;q<=RADIUS-1;q++)if(Math.abs(q+r)<=RADIUS-1){let[px,py]=axialToPixel(q,r,HEX_SIZE);let cx=L.offX+px*L.scale,cy=L.offY+py*L.scale;let s=HEX_SIZE*.96*L.scale;let p=document.createElementNS('http://www.w3.org/2000/svg','path');p.setAttribute('d',hexPath(cx,cy,s));p.classList.add('hex');let k=key(q,r);if(!boardState.has(k)){p.classList.add('empty');p.onclick=()=>place(q,r);}svg.appendChild(p);centers[k]=[cx,cy];}
 let last=history.length?history[history.length-1].k:null;
 for(const [k,v] of boardState.entries()){let[cx,cy]=centers[k];let g=document.createElementNS('http://www.w3.org/2000/svg','g');g.setAttribute('class',`stone ${v} ${k===last?'last-anim':''}`);let c=document.createElementNS('http://www.w3.org/2000/svg','circle');c.setAttribute('cx',cx);c.setAttribute('cy',cy);c.setAttribute('r',HEX_SIZE*.70*L.scale);g.appendChild(c);svg.appendChild(g);} 
 if(lastWinSegment){let l=document.createElementNS('http://www.w3.org/2000/svg','line');l.setAttribute('x1',lastWinSegment[0][0]);l.setAttribute('y1',lastWinSegment[0][1]);l.setAttribute('x2',lastWinSegment[1][0]);l.setAttribute('y2',lastWinSegment[1][1]);l.setAttribute('class','win-line');svg.appendChild(l);} 
 document.getElementById('turnText').textContent=gameOver?endMessage:(current==='white'?'白':'黄')+'の番です';
 document.getElementById('score').textContent=`白:${score.white} 勝 - 黄:${score.yellow} 勝`;
 document.getElementById('banner').hidden=!gameOver;
 document.getElementById('bannerMsg').textContent=endMessage;
}

function countDir(q,r,[dq,dr],pl){let n=0,cq=q,cr=r;while(boardState.get(key(cq+dq,cr+dr))===pl){cq+=dq;cr+=dr;n++;}return{n,cq,cr};}
function longestInfo(q,r,pl){let best={len:1,dir:null,front:null,back:null};for(const d of DIRS){const f=countDir(q,r,d,pl),b=countDir(q,r,[-d[0],-d[1]],pl);let len=1+f.n+b.n;if(len>best.len)best={len,dir:d,front:f,back:b};}return best;}
function exact3(q,r,pl){for(const d of DIRS){const f=countDir(q,r,d,pl),b=countDir(q,r,[-d[0],-d[1]],pl);if(1+f.n+b.n===3)return true;}return false;}
function segmentForWin(q,r,info){const[dq,dr]=info.dir;const startQ=q-dq*info.back.n,startR=r-dr*info.back.n;const endQ=q+dq*info.front.n,endR=r+dr*info.front.n;const[sx,sy]=axialToPixel(startQ,startR,HEX_SIZE),[ex,ey]=axialToPixel(endQ,endR,HEX_SIZE);return[[L.offX+sx*L.scale,L.offY+sy*L.scale],[L.offX+ex*L.scale,L.offY+ey*L.scale]];}

function place(q,r){if(gameOver)return;let k=key(q,r);if(boardState.has(k))return;boardState.set(k,current);history.push({k,player:current});
 const info=longestInfo(q,r,current);
 if(info.len>=4){gameOver=true;lastWinSegment=segmentForWin(q,r,info);endMessage=(current==='white'?'白':'黄')+'の勝ち！';score[current]++;}
 else if(exact3(q,r,current)){gameOver=true;lastWinSegment=null;endMessage=(current==='white'?'白':'黄')+'の負け！';score[current==='white'?'yellow':'white']++;}
 else current=current==='white'?'yellow':'white';
 render();
 if(!gameOver&&current==='yellow'&&aiLevel!=='off')setTimeout(aiMove,200);
}

function reset(){boardState.clear();history=[];gameOver=false;endMessage='';lastWinSegment=null;current='white';render();}
function undo(){if(history.length===0)return;const last=history.pop();boardState.delete(last.k);current=last.player;gameOver=false;endMessage='';lastWinSegment=null;render();}

function longestLenAt(state,q,r,pl){function count(sq,sr,d){let n=0,cq=sq,cr=sr;while(state.get(key(cq+d[0],cr+d[1]))===pl){cq+=d[0];cr+=d[1];n++;}return n;}let max=1;for(const d of DIRS){const len=1+count(q,r,d)+count(q,r,[-d[0],-d[1]]);if(len>max)max=len;}return max;}
function makesExact3(state,q,r,pl){function count(sq,sr,d){let n=0,cq=sq,cr=sr;while(state.get(key(cq+d[0],cr+d[1]))===pl){cq+=d[0];cr+=d[1];n++;}return n;}for(const d of DIRS){const len=1+count(q,r,d)+count(q,r,[-d[0],-d[1]]);if(len===3)return true;}return false;}
function cloneState(s=boardState){return new Map(s);} function applyMove(state,q,r,pl){let ns=cloneState(state);ns.set(key(q,r),pl);return ns;}
function legalMoves(state=boardState){const arr=[];for(let r=-RADIUS+1;r<=RADIUS-1;r++)for(let q=-RADIUS+1;q<=RADIUS-1;q++)if(Math.abs(q+r)<=RADIUS-1&&!state.has(key(q,r)))arr.push([q,r]);return arr;}

function aiMove(){
  const ME='yellow', OP='white';
  const all=legalMoves(); if(all.length===0) return;
  for(const [q,r] of all){const ns=applyMove(boardState,q,r,ME);if(longestLenAt(ns,q,r,ME)>=4) return place(q,r);} // 即勝ち
  let moves=all.filter(([q,r])=>!makesExact3(applyMove(boardState,q,r,ME),q,r,ME));
  if(!moves.length) moves=all.slice();

  function oppImmediateWin(state){for(const [oq,or] of legalMoves(state)){const ns=applyMove(state,oq,or,OP);if(longestLenAt(ns,oq,or,OP)>=4) return [oq,or];}return null;}
  const threat=oppImmediateWin(boardState);
  if(threat){const blk=moves.find(([q,r])=>q===threat[0]&&r===threat[1]); if(blk) return place(...blk);}

  function centerW(q,r){return -(q*q+r*r);}
  function heuristic(state){let s=0;for(const [k,v] of state.entries()){const [q,r]=k.split(',').map(Number);const len=longestLenAt(state,q,r,v);const cw=centerW(q,r)/10;const atom=(len===3?7:len*3)+cw;s+=v===ME?atom:-atom;}const t=oppImmediateWin(state);if(t) s-=60;return s;}
  function makesLose(state,q,r,pl){const w=longestLenAt(state,q,r,pl)>=4;const l=!w&&makesExact3(state,q,r,pl);return{win:w,lose:l};}
  function orderedMoves(state,pl){const ms=legalMoves(state).map(([q,r])=>{const ns=applyMove(state,q,r,pl);return{q,r,len:longestLenAt(ns,q,r,pl),cent:centerW(q,r)};});ms.sort((a,b)=> (b.len-a.len)||(b.cent-a.cent));return ms.map(m=>[m.q,m.r]);}

  const baseDepth=(aiLevel==='easy')?1:(aiLevel==='medium')?2:(aiLevel==='hard')?3:4;
  const TIME_LIMIT_MS=(aiLevel==='oni')?1000:300;
  const startTime=performance.now();

  function minimax(state,depth,alpha,beta,toMove){
    if(depth===0) return heuristic(state);
    const meTurn=(toMove===ME); const ms=orderedMoves(state,toMove);
    if(meTurn){let best=-1e9;for(const [q,r] of ms){const ns=applyMove(state,q,r,toMove);const res=makesLose(ns,q,r,toMove);let val;if(res.win) val=9999;else if(res.lose) val=-9999;else val=minimax(ns,depth-1,alpha,beta,OP);best=Math.max(best,val);alpha=Math.max(alpha,val);if(beta<=alpha) break;if(performance.now()-startTime>TIME_LIMIT_MS) break;}return best;}
    else{let best=1e9;for(const [q,r] of ms){const ns=applyMove(state,q,r,toMove);const res=makesLose(ns,q,r,toMove);let val;if(res.win) val=-9999;else if(res.lose) val=9999;else val=minimax(ns,depth-1,alpha,beta,ME);best=Math.min(best,val);beta=Math.min(beta,val);if(beta<=alpha) break;if(performance.now()-startTime>TIME_LIMIT_MS) break;}return best;}}

  let bestMove=null,bestVal=-1e9;const ordered0=orderedMoves(boardState,ME);
  for(let D=1;D<=baseDepth;D++){
    for(const [q,r] of ordered0){const ns=applyMove(boardState,q,r,ME);if(makesExact3(ns,q,r,ME)) continue;const val=minimax(ns,D-1,-1e9,1e9,OP);if(val>bestVal){bestVal=val;bestMove=[q,r];}if(performance.now()-startTime>TIME_LIMIT_MS) break;}
    if(performance.now()-startTime>TIME_LIMIT_MS) break;
  }
  if(aiLevel==='oni'){
    for(let D=baseDepth+1;D<=6;D++){
      for(const [q,r] of ordered0){const ns=applyMove(boardState,q,r,ME);if(makesExact3(ns,q,r,ME)) continue;const val=minimax(ns,D-1,-1e9,1e9,OP);if(val>bestVal){bestVal=val;bestMove=[q,r];}if(performance.now()-startTime>TIME_LIMIT_MS) break;}
      if(performance.now()-startTime>TIME_LIMIT_MS) break;
    }
  }
  if(!bestMove){const m=moves[Math.floor(Math.random()*moves.length)];return place(...m);}return place(...bestMove);
}

document.getElementById('resetBtn').onclick=reset;
document.getElementById('undoBtn').onclick=undo;
document.getElementById('aiLevel').onchange=e=>{aiLevel=e.target.value;if(aiLevel!=='off'&&current==='yellow'&&!gameOver)setTimeout(aiMove,200);};

render();
</script>
</body>
</html>
